#!/usr/bin/env bash
# memusg -- Measure memory usage of processes
# Usage: memusg COMMAND [ARGS]...
#
# Original Author: Jaeho Shin <netj@sparcs.org> 2010-08-16
# see https://gist.github.com/526585 (by user netj)
# Rewritten by: Jonathan Clark <jhclark@cs.cmu.edu> 2012-03-09
# Changes:
# * Track vmem
# * Write to stderr synchonously instead of spamming the console after the primary process terminates
# * Added some comments
# * Catch return code of the process being monitored

set -u

usage() {
    # Skip the shebang line and print the comment lines before the first empty comment
    # Oh, and uncomment them
    sed -n '2,/^#$/ s/^# //p' < "$0"
    exit 1
}

# check input
[ $# -gt 0 ] || usage

# TODO support more options: peak, footprint, sampling rate, etc.

# Get our process group ID
pgid=$(ps -o pgid= $$)
# If we're in the same process group as our parent, try to break out into a separate process group
if [ $pgid = $(ps -o pgid= $(ps -o ppid= $$)) ]; then
    echo >&2 "memusg: INFO: Launching new session / process group"
    setsid $0 "$@"
    exit $?
fi

# detect operating system and define measurement functions
case $(uname) in
    Darwin|*BSD)
        get_rss() {
            /bin/ps -o rss= -g $1 | awk '{n+=$0} END {print n}';
        }
        get_vmem() {
            /bin/ps -o vsize= -g $1 | awk '{n+=$0} END {print n}';
        }
        ;;
    Linux)
        get_rss() {
            #echo >&2 "memusg: INFO: Requesting RSS Sample: /bin/ps -o rss= --sid $1;"
            /bin/ps -o rss= --sid $1 | awk '{n+=$0} END {print n}';
        }
        get_vmem() {
            /bin/ps -o vsize= --sid $1 | awk '{n+=$0} END {print n}';
        }
        ;;
    *)
        echo "memusg: $(uname): unsupported operating system" >&2;
        exit 2
        ;;
esac

# run the given command
# (the command is all of our arguments)
COMMAND="$@"
echo >&2 "memusg: INFO: Running child command: $COMMAND"
"$@" &
childpid=$!
echo >&2 "memusg: INFO: Child PID is $childpid"

# monitor the memory usage while the program runs in the background
# entirely so that we can capture exit code of childpid
# (otherwise, we'd run in the foreground)
(
  set -u
  set -x
  #set -m # Enable job control in script
  pgid=$(ps -o pgid= $childpid)
  if [[ "$pgid" == "" ]]; then
      echo >&2 "ERROR: Could not detect return code of child program -- it might have exited immediately"
      echo >/dev/null # Could not determine process group id (Child process may have exited immediately
  else
      peak_rss=0
      peak_vmem=0
      while rss=$(get_rss $pgid); do
          sample_rss=$(( ${rss/#/+} ))
          let peak_rss="sample_rss > peak_rss ? sample_rss : peak_rss"
          
          vmem=$(get_vmem $pgid)
          if [[ "$vmem" != "" ]]; then
              sample_vmem=$(( ${vmem/#/+} ))
              let peak_vmem="sample_vmem > peak_vmem ? sample_vmem : peak_vmem"
          fi
          sleep 0.1
      done

      echo >&2 "memusg: Peak rss: ${peak_rss} kb"
      echo >&2 "memusg: Peak vmem: ${peak_vmem} kb"
  fi
) &
monpid=$!
echo >&2 "memusg: INFO: Monitor PID is $monpid"

# Just hope that we got here before losing the return code
# (The few millis spent launching the monitor process are a race condition)

# Now use wait to get the program's return code
wait $childpid
ecode=$?
wait $monpid
exit $ecode
